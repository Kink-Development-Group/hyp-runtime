// Simulierte Parallel-Ausführung ohne echte Threads
// Zeigt, wie Timing-Analysen mit den vorhandenen Builtins möglich sind

Focus {
    entrance {
        observe "=== Simulierte Parallel-Workloads ===";
        observe "Verfügbare CPU-Kerne laut Runtime: " + GetCpuCount();
        observe "Hostname: " + GetHostname();
        observe "";

        induce taskDurations: array = [120, 80, 150];
        induce total: number = 0;

        observe "Starte sequentielle Simulation von 3 Aufgaben.";

        pendulum (induce i: number = 0; i < 3; i = i + 1) {
            induce duration: number = entrain i {
                when 0 => 120
                when 1 => 80
                when 2 => 150
                otherwise => 0
            };
            observe "Aufgabe " + (i + 1) + " läuft für " + duration + " ms";
            observe "(simulierte Wartezeit: " + duration + " ms)";

            total = total + duration;
            murmur "Zwischenstand nach Aufgabe " + (i + 1) + ": " + total + " ms";
        }

        observe "Gesamtzeit (sequenziell): " + total + " ms";

        induce averageDuration = ArrayAverage(taskDurations);
        observe "Durchschnittliche Aufgabendauer: " + averageDuration + " ms";

        observe "Hinweis: Echte Nebenläufigkeit ist zukünftige Arbeit – diese Demo nutzt Drift für reproduzierbare Zeitmessungen.";
        observe "=== Simulation beendet ===";
    }
}

Relax
