// Simulated parallel execution without real threads
// Demonstrates how to perform timing analysis with existing builtins

Focus {
    entrance {
        observe "=== Simulated parallel workloads ===";
        observe "CPU cores according to runtime: " + GetCpuCount();
        observe "Hostname: " + GetHostname();
        observe "";

        induce taskDurations: array = [120, 80, 150];
        induce total: number = 0;

        observe "Starting sequential simulation of 3 tasks.";

        pendulum (induce i: number = 0; i < 3; i = i + 1) {
            induce duration: number = entrain i {
                when 0 => 120
                when 1 => 80
                when 2 => 150
                otherwise => 0
            };
            observe "Task " + (i + 1) + " runs for " + duration + " ms";
            observe "(simulated wait: " + duration + " ms)";

            total = total + duration;
            murmur "Progress after task " + (i + 1) + ": " + total + " ms";
        }

        observe "Total time (sequential): " + total + " ms";

        induce averageDuration = ArrayAverage(taskDurations);
        observe "Average task duration: " + averageDuration + " ms";

        observe "Note: real concurrency is future workâ€”this demo relies on drift for repeatable timing.";
        observe "=== Simulation complete ===";
    }
}

Relax
